#!/bin/bash

#
# XXX
#  - check that we're running as root
#  - top directory (/usr/local/crosware)
#    - software install dir (/usr/local/crosware/software/packagename-vX.Y.Z)
#    - download dir (/usr/local/crosware/download or ~/Downloads)
#    - build dir (/usr/local/crosware/build)
#    - current/previous symlinks for versioned installs
#    - ignore directories with generated files (path, cpp/ld flags, ...)
#    - ignore software install dir
#    - ignore 
#  - what will a "reboostrap" do?
#  - canonical arch
#    - use static "toybox file" to figure out?
#  - java arch
#  - all(?) aarch64 chrome os machines are using 32-bit armv7l userland (for arm chrome pepper/flash?)
#    - jdk will need to be arm on aarch64
#  - files to source w/path, compiler vars, pkg-config, etc.
#    - top-level etc/profile to source
#    - sources an etc/local and/or etc/local.d with shell snippets (obvious, local settings)
#    - reads in generated shell snippets (one per package) to set:
#      - PATH (etc/paths.d)
#      - CC, CXX, CFLAGS, CXXFLAGS, CPPFLAGS, LDFLAGS (etc/cppflags.d, etc/ldflags.d, ...)
#      - PKG_CONFIG_PATH, PKG_CONFIG_LIBDIR (etc/pkg-config.d)
#  - dependencies and dependants (maybe?)
#    - simple directory of files with pkgname.dependents, pkgname.dependencies
#  - install must chase down upstream deps
#  - update may require downstream dep updates
#

# make sure we're using bash and not sourced
if [ -z "${BASH_SOURCE}" -o "${0}" != "${BASH_SOURCE}" ] ; then
	echo "please execute this script instead of sourcing it"
	if [ "${0}" != "${BASH_SOURCE}" ] ; then
		return
	fi
	exit 1
fi

# check that we're using bash 4
if [ ${BASH_VERSINFO[0]} -lt 4 ] ; then
	echo "please make sure GNU Bash 4+ is in use"
	exit 1
fi

# exit early, exit often
set -eu

# architecture names and support
supported_archs=( aarch64 armv6l armv7l x86_64 )
karch="$(uname -m)"

# be somewhat strict about supported architectures
supported=0
for supported_arch in ${supported_archs[@]} ; do
	if [[ ${karch} =~ ^${supported_arch}$ ]] ; then
		supported=1
	fi
done
if [ ${supported} -eq 0 ] ; then
	echo "architecture ${karch} not yet supported"
	exit 1
fi

# userspace may be different than kernel, i.e., 32-bit arm on 64-bit aarch64
# we'll use the first chunk of bash $MACHTYPE environment variable
# it will be something like:
#   x86_64-cros-linux-gnu (x86_64 chrome os)
#   armv7a-cros-linux-gnu (armv7l and aarch64 chrome os with 32-bit userspace)
#   arm-unknown-linux-gnueabihf (armv7l (armv6l?) 32-bit debian/ubuntu/raspbian)
#   arm-unknown-linux-gnueabi (armv7l 32-bit debian?)
#   aarch64-unknown-linux-gnu (aarch64 full 64-bit debian/ubuntu)
#   aarch64-alpine-linux-musl (aarch64 full 64-bit alpine)
#   armv6-alpine-linux-musleabihf (armv6/armv7 32-bit alpine)
#   x86_64-generic-linux-gnu (intel clear linux)
#   x86_64-pc-linux-gnu (x86_64 debian/ubuntu)
#   x86_64-redhat-linux-gnu (x86_64 centos/rhel/fedora)
#   ...
# transform arm or armv7a to armv7l for parity with "uname -m"
# XXX - this assumes aarch64/x86_64 return the "right" $MACHTYPE
# XXX - this assumes we have hardware float on armv6/v7
bash_arch="${MACHTYPE%%-*}"
if [[ ${bash_arch} =~ ^arm ]] ; then
	if [[ ${karch} =~ ^aarch64 ]] ; then
		bash_arch="armv7l"
	elif [[ ${karch} =~ ^armv(6|7) ]] ; then
		bash_arch="${bash_arch/#arm*/$(uname -m)}"
	fi
fi
uarch="${bash_arch}"

echo "nothing to see here yet"
