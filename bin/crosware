#!/bin/bash

#
# XXX
#  - check that we're running as root
#    - note on perms if sudo/root is not wanted
#  - top directory (/usr/local/crosware)
#    - will need to checkout repo in $(dirname ${cwtop})
#    - software install dir (/usr/local/crosware/software/packagename/packagename-vX.Y.Z)
#    - download dir (/usr/local/crosware/download or ~/Downloads)
#    - build dir (/usr/local/crosware/build)
#    - current/previous symlinks for versioned installs
#    - ignore directories with generated files (path, cpp/ld flags, ...)
#    - ignore software install dir
#  - what will a "reboostrap" do?
#  - canonical arch
#    - use static "toybox file" to figure out?
#    - "user" arch (uarch), figured via bash $MACHTYPE environment variable
#    - kernel arch (karch), figured via uname -m
#  - java arch
#    - use zulu
#      - jdk 8
#    - glibc only
#    - armv6l/armv7l/armv8l hard float only (aarch32hf)
#    - aarch64
#    - i686
#    - x86_64 (x64)
#  - all(?) aarch64 chrome os machines are using 32-bit armv7l userland (for arm chrome pepper/flash?)
#    - jdk will need to be arm on aarch64
#  - handle armv8l 32-bit compat on aarch64
#    - treat like armv6l/armv7l
#  - arm soft-float?
#    - bash will return something like armv5tel
#    - need sf zulu jdk, compiler set
#    - probably not worth it
#  - handle i686
#    - no current, supported intel chrome os devices are 32-bit
#    - maybe grab neverware cloudready 32b for testing?
#    - i686 *only*, no i386/i486/i586
#  - files to source w/path, compiler vars, pkg-config, etc.
#    - top-level etc/profile to source
#    - sources an etc/local and/or etc/local.d with shell snippets (obvious, local settings)
#    - reads in generated shell snippets (one per package) to set:
#      - PATH (etc/paths.d)
#      - CC, CXX, CFLAGS, CXXFLAGS, CPPFLAGS, LDFLAGS (etc/cppflags.d, etc/ldflags.d, ...)
#      - PKG_CONFIG_PATH, PKG_CONFIG_LIBDIR (etc/pkg-config.d)
#  - dependencies and dependants (maybe?)
#    - simple directory of files with pkgname.dependents, pkgname.dependencies
#  - install must chase down upstream deps
#  - update may require downstream dep updates
#    - var/deps/recipename/depname
#    - var/reqs/recipename/reqname
#  - etc/local.d - scriptlets, not tracked in git
#  - var/ - track installs/versions
#  - jgit.sh doesn't have "jgit.sh pull" shortcut; use:
#    - jgit.sh fetch origin ; jgit.sh merge origin/master
#  - where to store recipe scriptlets?
#    - and how abstract should they be?
#  - update environment without rebootstrap
#  - profile.d file writer
#  - zulu, jgitsh, static-toolchain split out to separate install functions
#    - trim down bootstrap/make 
#    - make them easier to upgrade
#  - recipes
#    - rname - recipe name
#    - rver - recipe version
#    - rrel - internal release to aid upgrade? - XXX
#    - rbreqs - split rreqs into normal requirements (rreqs) and build requirements
#    - rbdir - recipe build dir
#    - rtdir - recipe top dir where installs are done
#    - ridir - versioned recipe install dir
#    - rprof - profile.d file
#    - rdeps / rbdeps? - deps and build deps?
#    - rdesc - recipe description?
#    - rold - list of old versions to clean up recipes that don't fully remove rdir?
#    - need to set sane default r* values in common.sh with ': ${rblah:="blah.setting"}'
#    - unset vals after parse so there's no bleed through?
#    - generic profile.d generator
#      - find bin dir, append_path it
#      - find pc files, append_pkgcfg the dirs
#      - libs...
#      - inclues...
#    - custom/pre/post functions
#  - recipe/function names
#    - need _ instead of - (?)
#    - rename static-toolchain back to static_toolchain (?)
#  - whatprovides functionality
#    - given a program or dir/subdir/blah path pattern dump the all directory names under software/ that match
#    - generate index of files at install time
#  - os detector
#    - chrome os/chromium os
#    - alpine
#    - centos
#    - debian
#    - ubuntu
#  - deleted recipes can't be uninstalled (i.e, break when moving bison.sh to .OFF)
#  - cppflags/ldflags need to have dupes removed
#  - need ca certs for links/lynx/etc.
#  - setup a sysroot directory structure?
#    - perl recipe has a simple example
#    - fake /bin, /lib, /usr/bin, /usr/include, /usr/lib from static toolchain
#    - link in/bind mount
#    - add busybox/toybox (and real bash) for a chroot-able environment?
#  - man wrapper
#    - busybox (man), less, groff
#    - sets PAGER to (real less) "less -R"
#    - MANPATH?
#  - need a fallback mirror
#  - XXX - unset recipe vars should be a list
#  - XXX - cwinstall() should likely use associative array to only do a single install
#    - i.e., "crosware install make m4 make flex make" should only install the make recipe *once*
#  - XXX - zulu/static-toolchain/jgitsh should have cwinstall/cwname/cwver/_... funcs
#  - XXX - downloads should go into ${cwdl}/${rname}/${rfile}
#    - and all fetching should happen in cwfetch_recipe func
#    - can run offline after all fetches are done
#

#
# we'll use these everywhere
#
export cwname="crosware"
if [[ ${0} =~ ^/dev/fd/ ]] ; then
  scriptname="${cwname}"
else
  scriptname="$(basename ${0})"
fi

function cwscriptecho() {
  echo -e "${scriptname}: ${1}"
}

function cwfailexit() {
  cwscriptecho "${1}"
  exit 1
}

#
# shell feature and usage check
#

# make sure we're using bash and not sourced
if [ -z "${BASH_SOURCE}" -o "${0}" != "${BASH_SOURCE}" ] ; then
  echo "please execute this script instead of sourcing it"
  if [ "${0}" != "${BASH_SOURCE}" ] ; then
    return
  fi
  exit 1
fi

# check that we're using bash 4
if [ ${BASH_VERSINFO[0]} -lt 4 ] ; then
  cwfailexit "please make sure GNU Bash 4+ is in use"
fi

# exit early, exit often
set -eu

#
# prereqs
#
# XXX - curl, sha256sum, ... ? what else? check for tls/ssl support?
prereqs=( 'bzip2' 'curl' 'sha256sum' )
for prereq in ${prereqs[@]} ; do
  hash "${prereq}" >/dev/null 2>&1 || {
    cwfailexit "${prereq} not found"
  }
done

#
# script options/commands/variables
#
: ${cwurl:="https://github.com/ryanwoodsmall/${cwname}.git"}
: ${cworigin:="origin"}
: ${cwbranch:="master"}
declare -A cwcmds
cwcmds["help"]="show help"
cwcmds["bootstrap"]="bootstrap ${cwname}"
cwcmds["env"]="dump source-/eval-able ${cwname} etc/profile"
cwcmds["profile"]="show .profile addition"
cwcmds["list-recipes"]="list build recipes"
cwcmds["install"]="attempt to build/install a package from a known recipe"
cwcmds["update"]="attempt to update existing install of ${cwname}"
cwcmds["list-installed"]="list installed recipes"
cwcmds["uninstall"]="uninstall some packages"
cwcmds["set"]="run 'set' to show full ${cwname} environment"
cwcmds["list-available"]="list available recipes which are not installed"
cwcmds["list-funcs"]="list ${cwname} shell functions"
cwcmds["run-func"]="run ${cwname} shell function"
cwcmds["show-env"]="run 'env' to show ${cwname} environment"
cwcmdlist=( $(echo ${!cwcmds[@]} | tr ' ' '\n' | sort | xargs echo) )

#
# common commands
#
# extract commands
export cwuntbz2="tar -jxf"
export cwuntgz="tar -zxf"
export cwuntxz="tar -Jxf"

#
# common opts
#
# curl
#   -f for fail on http error
#   -k accept insecure certs
#   -L follow redirects
#   -s for silent downloads?
export copts="-f -k -L -s"

#
# where we live
#
# XXX - default to /usr/local/crosware but allow override (that may or may not work)
: ${cwtop:="/usr/local/${cwname}"}
export cwtop
export cwbin="${cwtop}/bin"
export cwbuild="${cwtop}/builds"
export cwdl="${cwtop}/downloads"
export cwetc="${cwtop}/etc"
export cwrecipe="${cwtop}/recipes"
export cwetcprofile="${cwetc}/profile"
export cwetcprofd="${cwetc}/profile.d"
export cwsw="${cwtop}/software"
export cwtmp="${cwtop}/tmp"
export cwvar="${cwtop}/var"
export cwvarinst="${cwvar}/inst"

# we'll use this for bootstrap since /tmp may be mounted noexec
: ${cwtmptmp:="/usr/local/tmp"}
export cwtmptmp

# temp dir permissions
export cwtmpperm="1777"

# execute perms
export cwexecperm="775"

# start off with an empty recipe list
declare -A cwrecipes cwbootstraprecipes
export cwrecipes
export cwbootstraprecipes

# and a "user-visible" var whether we want to use an external jvm/jdk
: ${CW_EXT_JAVA:="false"}
export CW_EXT_JAVA
# time travel?
: ${TS:="$(date '+%Y%m%d%H%M%S')"}
export TS

#
# supported architecture check
#

# architecture names and support
supported_arches=( aarch64 armv6l armv7l armv8l i686 x86_64 )
export karch="$(uname -m)"

# be somewhat strict about supported architectures
supported=0
for supported_arch in ${supported_arches[@]} ; do
  if [[ ${karch} =~ ^${supported_arch}$ ]] ; then
    supported=1
  fi
done
if [ ${supported} -eq 0 ] ; then
  cwfailexit "architecture ${karch} not supported"
fi

#
# userspace vs kernel architecture check
#

# userspace may be different than kernel, i.e., 32-bit arm on 64-bit aarch64
# we'll use the first chunk of bash $MACHTYPE environment variable
# it will be something like:
#   x86_64-cros-linux-gnu (x86_64 chrome os)
#   armv7a-cros-linux-gnu (armv7l and aarch64 chrome os with 32-bit userspace)
#   arm-unknown-linux-gnueabihf (armv7l (armv6l?) 32-bit debian/ubuntu/raspbian)
#   arm-unknown-linux-gnueabi (armv7l 32-bit debian?)
#   aarch64-unknown-linux-gnu (aarch64 full 64-bit debian/ubuntu)
#   aarch64-alpine-linux-musl (aarch64 full 64-bit alpine)
#   armv6-alpine-linux-musleabihf (armv6/armv7 32-bit alpine)
#   x86_64-generic-linux-gnu (intel clear linux)
#   x86_64-pc-linux-gnu (x86_64 debian/ubuntu)
#   x86_64-redhat-linux-gnu (x86_64 centos/rhel/fedora)
#   i586-alpine-linux-musl (x86 alpine)
#   i686-pc-linux-gnu (i686 debian/ubuntu)
#   i386-redhat-linux-gnu (i686 centos)
#   ...
# transform arm or armv7a to armv7l for parity with "uname -m"
# XXX - this assumes aarch64/x86_64 return the "right" $MACHTYPE
# XXX - this assumes we have hardware float on armv6/v7
# XXX - HOSTTYPE is the first part of MACHTYPE
export bash_triplet="${MACHTYPE}"
bash_arch="${MACHTYPE%%-*}"
if [[ ${bash_arch} =~ ^arm ]] ; then
  if [[ ${bash_arch} =~ ^armv5 ]] ; then
    cwfailexit "it looks like your machine type is ${MACHTYPE}; the minimum is armv6 with hardware float"
  fi
  if [[ ${karch} =~ ^aarch64 ]] ; then
    bash_arch="armv7l"
  elif [[ ${karch} =~ ^armv(6|7|8) ]] ; then
    bash_arch="${bash_arch/#arm*/$(uname -m)}"
  fi
elif [[ ${bash_arch} =~ ^i.86 ]] ; then
  bash_arch="i686"
fi
export uarch="${bash_arch}"

#
# bootstrap vars
#

#
# zulu jdk setup (for bootstrap)
#

# XXX - zulu jdk arch will be uarch

# basic zulu vars
zulu_pkgname="zulu"
zulu_inst_dir="${cwsw}/${zulu_pkgname}"

# zulu environment
declare -A zulu_env
zulu_env["_JAVA_OPTIONS"]="-Djava.io.tmpdir=${cwtmp} -Djava.awt.headless=true"
zulu_env["JAVA_HOME"]="${zulu_inst_dir}/current"
zulu_env["PATH"]='${PATH}:${JAVA_HOME}/bin'
zulu_envs=( "_JAVA_OPTIONS" "JAVA_HOME" "PATH" )

# zulu jdk arch map
# XXX - arm 32-bit hard float assumption, again
declare -A zulu_jdk_arch
zulu_jdk_arch["aarch64"]="aarch64"
zulu_jdk_arch["armv6l"]="aarch32hf"
zulu_jdk_arch["armv7l"]="aarch32hf"
zulu_jdk_arch["armv8l"]="aarch32hf"
zulu_jdk_arch["i686"]="i686"
zulu_jdk_arch["x86_64"]="x64"

# zulu jdk version map
declare -A zulu_jdk_ver
zulu_jdk_ver["aarch64"]="1.8.0_152-8.25.0.79"
zulu_jdk_ver["armv6l"]="1.8.0_152-8.25.0.76"
zulu_jdk_ver["armv7l"]="1.8.0_152-8.25.0.76"
zulu_jdk_ver["armv8l"]="1.8.0_152-8.25.0.76"
zulu_jdk_ver["i686"]="8.25.0.3-jdk8.0.153"
zulu_jdk_ver["x86_64"]="8.27.0.7-jdk8.0.162"

# zulu jdk file sha256sum
declare -A zulu_jdk_sha256sum
zulu_jdk_sha256sum["aarch64"]="45997b734a0d3ec5035b836f8c235d291c677547811704e3c62f656ee943cdc8"
zulu_jdk_sha256sum["armv6l"]="a7bc9f9edd1cf60aad51b9c6b93c8dcf49af87891b8de5d7982d0d97bfb43636"
zulu_jdk_sha256sum["armv7l"]="a7bc9f9edd1cf60aad51b9c6b93c8dcf49af87891b8de5d7982d0d97bfb43636"
zulu_jdk_sha256sum["armv8l"]="a7bc9f9edd1cf60aad51b9c6b93c8dcf49af87891b8de5d7982d0d97bfb43636"
zulu_jdk_sha256sum["i686"]="1a12eae6d8497ec001d1fbbc7dad68d1c2c687d52cf28671b427ff788c1c6ef8"
zulu_jdk_sha256sum["x86_64"]="8940e6e12a326ede65e55a0fd3815387862e3fa42684eb49cb3b52fbde8b0c4f"

# zulu directory, file, and url map
declare -A zulu_jdk_dir zulu_jdk_file zulu_jdk_url
for supported_arch in ${supported_arches[@]} ; do
  if [[ ${supported_arch} =~ ^(i686|x86_64)$ ]] ; then
    zulu_jdk_dir[${supported_arch}]="zulu${zulu_jdk_ver[${supported_arch}]}-linux_${zulu_jdk_arch[${supported_arch}]}"
    zulu_jdk_base_url="http://cdn.azul.com/zulu/bin"
  elif [[ ${supported_arch} =~ ^a(rmv|arch) ]] ; then
    zulu_jdk_dir[${supported_arch}]="ezdk-${zulu_jdk_ver[${supported_arch}]}-eval-linux_${zulu_jdk_arch[${supported_arch}]}"
    zulu_jdk_base_url="http://cdn.azul.com/zulu-embedded/bin"
  fi
  zulu_jdk_file[${supported_arch}]="${zulu_jdk_dir[${supported_arch}]}.tar.gz"
  zulu_jdk_url[${supported_arch}]="${zulu_jdk_base_url}/${zulu_jdk_file[${supported_arch}]}"
done

#
# jgit
#

# XXX - will need to make sure java tmpdir is set
# https://repo.eclipse.org/content/groups/releases/org/eclipse/jgit/org.eclipse.jgit.pgm/4.9.1.201712030800-r/org.eclipse.jgit.pgm-4.9.1.201712030800-r.sh
jgitsh_ver="4.10.0.201712302008-r"
jgitsh_file="org.eclipse.jgit.pgm-${jgitsh_ver}.sh"
jgitsh_url="https://repo.eclipse.org/content/groups/releases/org/eclipse/jgit/org.eclipse.jgit.pgm/${jgitsh_ver}/${jgitsh_file}"
jgitsh_sha256sum="76305c50c934f05838d876604a474b188b6b7a374aa87923eb5803028fcf8cd9"
jgitsh_symlink="jgit.sh"
jgitsh_pkgname="jgitsh"
jgitsh_inst_dir="${cwsw}/${jgitsh_pkgname}"

# jgit environment
declare -A jgitsh_env
jgitsh_env["PATH"]="\${PATH}:${jgitsh_inst_dir}/current/bin"
jgitsh_envs=( "PATH" )

#
# static compiler bootstrap
#

# XXX - compiler arch will be karch/uname -m

# common static compiler release/tag, archive, and url
static_toolchain_archive_ext="tar.bz2"
static_toolchain_checksum_ext="sha256"
static_toolchain_release="20180224"
static_toolchain_base_url="https://github.com/ryanwoodsmall/musl-misc/releases/download"
static_toolchain_release_url="${static_toolchain_base_url}/${static_toolchain_release}"
static_toolchain_pkgname="static-toolchain"
static_toolchain_inst_dir="${cwsw}/${static_toolchain_pkgname}"

# architecture to musl triplet
declare -A static_toolchain_triplet
static_toolchain_triplet["aarch64"]="aarch64-linux-musl"
static_toolchain_triplet["armv6l"]="arm-linux-musleabihf"
static_toolchain_triplet["armv7l"]="arm-linux-musleabihf"
static_toolchain_triplet["armv8l"]="arm-linux-musleabihf"
static_toolchain_triplet["i686"]="i686-linux-musl"
static_toolchain_triplet["x86_64"]="x86_64-linux-musl"

# architecture to release prefix
declare -A static_toolchain_prefix
static_toolchain_prefix["aarch64"]="201802240613"
static_toolchain_prefix["armv6l"]="201802240613"
static_toolchain_prefix["armv7l"]="201802240613"
static_toolchain_prefix["armv8l"]="201802240613"
static_toolchain_prefix["i686"]="201802240613"
static_toolchain_prefix["x86_64"]="201802240613"

# architecture to filename, urls, sha256 file, dir, ...
declare -A static_toolchain_file static_toolchain_checksum static_toolchain_checksum_file static_toolchain_file_url static_toolchain_checksum_url static_toolchain_dir
for supported_arch in ${supported_arches[@]} ; do
  static_toolchain_file[${supported_arch}]="${static_toolchain_prefix[${supported_arch}]}-${static_toolchain_triplet[${supported_arch}]}.${static_toolchain_archive_ext}"
  static_toolchain_checksum_file[${supported_arch}]="${static_toolchain_file[${supported_arch}]}.${static_toolchain_checksum_ext}"
  static_toolchain_file_url[${supported_arch}]="${static_toolchain_release_url}/${static_toolchain_file[${supported_arch}]}"
  static_toolchain_checksum_url[${supported_arch}]="${static_toolchain_release_url}/${static_toolchain_checksum_file[${supported_arch}]}"
  static_toolchain_dir[${supported_arch}]="${static_toolchain_prefix[${supported_arch}]}-${static_toolchain_triplet[${supported_arch}]}"
done

# static toolchain environment
# XXX - set more ld flags? -s/--strip-all or -S/--strip-debug
declare -A static_toolchain_env
static_toolchain_env["PATH"]="${static_toolchain_inst_dir}/current/bin:\${PATH}"
static_toolchain_env["CFLAGS"]="-Wl,-static"
static_toolchain_env["CXXFLAGS"]="-Wl,-static"
static_toolchain_env["LDFLAGS"]="-static \${LDFLAGS}"
static_toolchain_env["CC"]="${static_toolchain_triplet[${karch}]}-gcc"
static_toolchain_env["CXX"]="${static_toolchain_triplet[${karch}]}-g++"
static_toolchain_env["LD"]="${static_toolchain_triplet[${karch}]}-ld"
static_toolchain_env["CPP"]="${static_toolchain_triplet[${karch}]}-cpp"
static_toolchain_env["AR"]="${static_toolchain_triplet[${karch}]}-ar"
static_toolchain_env["AS"]="${static_toolchain_triplet[${karch}]}-as"
static_toolchain_envs=( "PATH" "CFLAGS" "CXXFLAGS" "LDFLAGS" "CC" "CXX" "CPP" "LD" "AR" "AS" )

#
# "special" bootstrap recipes
#
for cwbootstraprecipe in "${zulu_pkgname}" "${jgitsh_pkgname}" "${static_toolchain_pkgname}" ; do
  cwbootstraprecipes["${cwbootstraprecipe}"]=1
done
export cwbootstraprecipes

#
# cwmkdir
#   mkdir -p with check/wrapper
#
function cwmkdir() {
  local tgtdir="${1}"
  if [ ! -e "${tgtdir}" ] ; then
    cwscriptecho "creating directory ${tgtdir}"
    mkdir -p "${tgtdir}" || cwfailexit "could not create ${tgtdir}"
  fi
  test -e "${tgtdir}" || cwfailexit "${tgtdir} still doesn't exist"
}

#
# cwchmod
#   chmod wrapper
#   receives:
#     octal mode
#     path
#
function cwchmod() {
  local tgtmode="${1}"
  local tgtpath="${2}"
  cwscriptecho "setting mode ${tgtmode} on ${tgtpath}"
  chmod "${tgtmode}" "${tgtpath}" || cwfailexit "could not set mode ${tgtmode} on ${tgtpath}"
}

# cwmkcwtmptmp
#   check and make our temporary temporary directory
#
function cwmkcwtmptmp() {
  if [ ! -e "${cwtmptmp}" ] ; then
    cwmkdir "${cwtmptmp}"
    cwchmod "${cwtmpperm}" "${cwtmptmp}"
  fi
}

#
# cwfetch
#   receives:
#     url to download
#     full path to save file to
function cwfetch() {
  local downloadurl="${1}"
  local targetfile="${2}"
  cwscriptecho "downloading ${downloadurl} to ${targetfile}"
  curl ${copts} -o "${targetfile}" "${downloadurl}"
  if [ "${?}" -eq 0 ] ; then
    cwscriptecho "successfully downloaded ${downloadurl} to ${targetfile}"
    return 0
  else
    cwfailexit "curl failed for ${downloadurl}"
    return 1
  fi
}

#
# cwchecksha256sum
#   receives:
#     full path to file to check
#     sha256sum for comparison
function cwchecksha256sum() {
  local checkfile="${1}"
  local storedsha256sum="${2}"
  cwscriptecho "checking sha256sum for ${checkfile}"
  local sha256sum="$(sha256sum ${checkfile} | awk '{print $1}')"
  if [ "${storedsha256sum}" == "${sha256sum}" ] ; then
    cwscriptecho "sha256 checksum succeeded for ${checkfile}"
    return 0
  else
    cwscriptecho "sha256 checksum failed for ${checkfile}"
    return 1
  fi
}

#
# cwfetchcheck
#   receives:
#     url to download
#     full path to save file
#     sha256sum for comparison
#
function cwfetchcheck() {
  local downloadurl="${1}"
  local targetfile="${2}"
  local storedsha256sum="${3}"
  if [ -e "${targetfile}" ] ; then
    cwscriptecho "${targetfile} already exists"
    local sha256sum="$(sha256sum ${targetfile} | awk '{print $1}')"
    if [ "${storedsha256sum}" == "${sha256sum}" ] ; then
      cwscriptecho "existing ${targetfile} matched checksum"
      return
    else
      cwscriptecho "existing ${targetfile} failed checksum, redownloading"
    fi
  fi
  cwfetch "${downloadurl}" "${targetfile}"
  cwchecksha256sum "${targetfile}" "${storedsha256sum}" || cwfailexit "fetch and sha256 checksum of ${downloadurl} failed"
}

#
# cwextract
#   receives:
#     full path to file
#     target directory
#
function cwextract() {
  local archive="${1}"
  local tgtdir="${2}"
  test -e "${tgtdir}" || cwmkdir "${tgtdir}"
  cwscriptecho "extracting ${archive} to ${tgtdir}"
  if [[ ${archive} =~ \.t(|ar)(|.)bz(|2)$ ]] ; then
    ${cwuntbz2} "${archive}" -C "${tgtdir}"
  elif [[ ${archive} =~ \.t(|ar)(|.)gz$ ]] ; then
    ${cwuntgz} "${archive}" -C "${tgtdir}"
  elif [[ ${archive} =~ \.t(|ar)(|.)xz$ ]] ; then
    ${cwuntxz} "${archive}" -C "${tgtdir}"
  else
    cwfailexit "archive type of ${archive} not understood"
  fi
  if [ ${?} -eq 0 ] ; then
    cwscriptecho "extraction of ${archive} succeeded"
  else
    cwfailexit "extraction of ${archive} failed"
  fi
}

#
# cwlinkdir
#   receives:
#     directory name/path (relative or full)
#     full path to a directory to run in
#
# shuffles previous/current symlinks
#
function cwlinkdir() {
  local linktgt="${1}"
  local linkdir="${2}"
  local prev="${linkdir}/previous"
  local curr="${linkdir}/current"
  cwscriptecho "setting up ${linktgt} symlink in ${linkdir}"
  if [ -e "${prev}" ] ; then
    rm -f "${prev}" || cwfailexit "could not remove ${prev}"
  fi
  if [ -e "${curr}" ] ; then
    mv "${curr}" "${prev}" || cwfailexit "could not move ${curr} to ${prev}"
  fi
  ln -sf "${linktgt}" "${curr}" || cwfailexit "could not symlink ${linktgt} to ${curr}"
}

#
# cwexpandenv
#   receives:
#     name of var
#     full path of file to expand into
#
# expands environment variables for a given name
# assumes the existence of:
#   example_env['VAR']='value' - hash/associative array
#   example_envs[0]='VAR' - normal array controlling expanded vars and ordering
#
function cwexpandenv() {
  local name="${1}"
  local envfile="${2}"
  if [ -e "${envfile}" ] ; then
    rm -f "${envfile}" || cwfailexit "could not remove existing ${envfile}"
  fi
  echo -n > "${envfile}" || cwfailexit "could not (re)create ${envfile}"
  for var in $(eval echo \${${name}_envs[@]}) ; do
    echo "export ${var}=\"$(eval echo \${${name}_env[${var}]})\"" >> "${envfile}"
  done
}

#
# cwprofileline
#
function cwprofileline() {
  echo
  echo "  test -e ${cwetc}/profile && source ${cwetcprofile}"
  echo
}

#
# cwbootstrap
#
function cwbootstrap() {
  bootstrapped=1
  # check if we're already bootstrapped and fetch/merge if we are
  if [ -e "${cwtop}" ] ; then
    bootstrapped=0
  fi
  cwscriptecho "bootstrapping"
  # make sure we have a tmp directory
  cwmkcwtmptmp
  # architecture specfic toolchain checksum file
  local statictoolchainchecksumfile="${cwtmptmp}/${static_toolchain_checksum_file[${karch}]}"
  cwfetch "${static_toolchain_checksum_url[${karch}]}" "${statictoolchainchecksumfile}"
  local statictoolchainchecksum="$(awk '{print $1}' ${statictoolchainchecksumfile})"
  # static toolchain
  local statictoolchainarchive="${cwtmptmp}/${static_toolchain_file[${karch}]}"
  cwfetchcheck "${static_toolchain_file_url[${karch}]}" "${statictoolchainarchive}" "${statictoolchainchecksum}"
  # jgit
  local jgitsh="${cwtmptmp}/${jgitsh_file}"
  cwfetchcheck "${jgitsh_url}" "${jgitsh}" "${jgitsh_sha256sum}"
  cwchmod "${cwexecperm}" "${jgitsh}"
  ln -sf "${jgitsh_file}" "${cwtmptmp}/${jgitsh_symlink}"
  export PATH="${cwtmptmp}:${PATH}"
  # zulu
  if [ "${CW_EXT_JAVA}" == "false" ] ; then
    local zuluarchive="${cwtmptmp}/${zulu_jdk_file[${uarch}]}"
    local zulujdkdir="${cwtmptmp}/${zulu_jdk_dir[${uarch}]}"
    cwfetchcheck "${zulu_jdk_url[${uarch}]}" "${zuluarchive}" "${zulu_jdk_sha256sum[${uarch}]}"
    cwextract "${zuluarchive}" "${cwtmptmp}"
    # add zulu and tmp dir (for jgit) to our path
    export JAVA_HOME="${zulujdkdir}"
    export PATH="${JAVA_HOME}/bin:${PATH}"
  fi
  # clone or fetch the repo
  if [ ${bootstrapped} -eq 1 ] ; then
    cwscriptecho "attempting to clone ${cwurl} into ${cwtop}"
    ${jgitsh} clone "${cwurl}" "${cwtop}" || cwfailexit "could not clone ${cwurl} into ${cwtop}"
  else
    cwupdate
  fi
  # setup our base tools
  # zulu
  if [ "${CW_EXT_JAVA}" == "false" ] ; then
    mkdir -p "${zulu_inst_dir}"
    cwextract "${zuluarchive}" "${zulu_inst_dir}"
    cwlinkdir "${zulu_jdk_dir[${uarch}]}" "${zulu_inst_dir}"
    cwexpandenv "${zulu_pkgname}" "${cwetcprofd}/${zulu_pkgname}.sh"
    cwmarkinstall "${zulu_pkgname}" "${zulu_jdk_ver[${uarch}]}"
  fi
  # jgit
  mkdir -p "${jgitsh_inst_dir}/${jgitsh_ver}/bin"
  cp -a "${jgitsh}" "${jgitsh_inst_dir}/${jgitsh_ver}/bin/"
  ln -sf "${jgitsh_file}" "${jgitsh_inst_dir}/${jgitsh_ver}/bin/${jgitsh_symlink}"
  ln -sf "${jgitsh_file}" "${jgitsh_inst_dir}/${jgitsh_ver}/bin/${jgitsh_symlink/%.sh/}"
  cwlinkdir "${jgitsh_ver}" "${jgitsh_inst_dir}"
  cwexpandenv "${jgitsh_pkgname}" "${cwetcprofd}/${jgitsh_pkgname}.sh"
  cwmarkinstall "${jgitsh_pkgname}" "${jgitsh_ver}"
  # toolchain
  mkdir -p "${static_toolchain_inst_dir}"
  cwextract "${statictoolchainarchive}" "${static_toolchain_inst_dir}"
  cwlinkdir "${static_toolchain_dir[${karch}]}" "${static_toolchain_inst_dir}"
  cwexpandenv "static_toolchain" "${cwetcprofd}/${static_toolchain_pkgname}.sh"
  cwmarkinstall "${static_toolchain_pkgname}" "${static_toolchain_prefix[${karch}]}"
  # set tmp directory perm
  cwchmod "${cwtmpperm}" "${cwtmp}"
  # we're bootstrapped...
  cwscriptecho "bootstrap complete"
  cwscriptecho "add ${cwname} to your environment with a line in your .profile/.bash_profile/.bashrc"
  cwprofileline
  # XXX - add to installed/db/...
  # XXX - cleanup temp files?
  if [ "${CW_EXT_JAVA}" == "false" ] ; then
    cwscriptecho "removing temporary zulu jdk directory"
    rm -rf "${zulujdkdir}"
  fi
}

#
# cwsourceprofile
#
function cwsourceprofile() {
  source "${cwetcprofile}"
}

#
# cwupdate
#
function cwupdate() {
  if [ -e "${cwtop}" ] ; then
    cwscriptecho "it looks like ${cwtop} already exists, attempting update"
    if [ ! -e "${cwtop}/.git" ] ; then
      cwfailexit "${cwtop} doesn't appear to be a git clone"
    else
      cwsourceprofile
      cwscriptecho "attempting to fetch/merge in ${cwtop}"
      pushd "${cwtop}" >/dev/null 2>&1 || cwfailexit "could not pushd into ${cwtop}"
      ${jgitsh_symlink} fetch "${cworigin}" || { popd ; cwfailexit "could not fetch ${cworigin} in ${cwtop}" ; }
      ${jgitsh_symlink} merge "${cworigin}/${cwbranch}" || { popd ; cwfailexit "could not merge ${cworigin}/${cwbranch} in ${cwtop}" ; }
      popd >/dev/null 2>&1
      cwchmod "${cwtmpperm}" "${cwtmp}"
    fi
  else
    cwfailexit "${cwtop} does not exist, have you run '${cwname} bootstrap' yet?"
  fi
}

#
# cwsourcerecipes
#
function cwsourcerecipes() {
  if [ ! -e ${cwrecipe} ] ; then
    cwscriptecho "no recipe directory ${cwrecipe} found"
    return 1
  fi
  for recipe in ${cwrecipe}/*/*.sh ; do
    source ${recipe}
    cwrecipes["${rname}"]=1
    unset rname rver rfile rurl rprof rreqs rbreqs rsha256 rdir ridir rbdir rtdir rdeps rbdeps
  done
  unset recipe
  export cwrecipes
}

#
# cwlistrecipes
#
function cwlistrecipes() {
  cwsourcerecipes
  for recipe in ${!cwrecipes[@]} ; do
    echo "${recipe}"
  done | sort
}

#
# cwinstall
#
# build/install some stuff
#
function cwinstall() {
  local recipestobuild=()
  cwsourceprofile
  cwsourcerecipes
  for recipe in "${@}" ; do
    if ! $(set | grep -q "^cwinstall_${recipe}") ; then
      cwfailexit "recipe ${recipe} not found"
    fi
    recipestobuild[${#recipestobuild[@]}]="cwinstall_${recipe}"
  done
  test ${#recipestobuild[@]} -eq 0 && cwfailexit "please provide at least one valid recipe to build"
  for buildrecipe in ${recipestobuild[@]} ; do
    cwsourceprofile
    cwscriptecho "building recipe ${buildrecipe//cwinstall_/}"
    ${buildrecipe}
  done
}

#
# cwmarkinstall
#   receives:
#     package/recipe name
#     package/recipe version
#
# writes a file to ${cwvarinst}/${pkgname} containing the pkg version
#
function cwmarkinstall() {
  local pkgname="${1}"
  local pkgver="${2}"
  local pkgfile="${cwvarinst}/${pkgname}"
  cwmkdir "${cwvarinst}"
  echo "${pkgver}" > "${pkgfile}" || cwfailexit "could not write ${pkgfile}"
}

#
# cwlistinstalled
#
function cwlistinstalled() {
  local pkgname=""
  for pkgname in $(find ${cwvarinst} -maxdepth 1 -type f ! -name .\* | sort) ; do
    echo "$(basename ${pkgname}) : $(cat ${pkgname})"
  done
}

#
# cwcheckinstalled
#   receives:
#     recipe package name
#
# returns 0 if installed, 1 if not
#
function cwcheckinstalled() {
  local pkgname="${1}"
  if $(cwlistinstalled | grep -q "^${pkgname} :") ; then
    return 0
  else
    return 1
  fi
}

#
# cwlistavailable
#
# lists available but uninstalled recipes
#
function cwlistavailable() {
  local pkgname=""
  for pkgname in $(cwlistrecipes) ; do
    if ! $(cwcheckinstalled ${pkgname}) ; then
      echo "${pkgname}"
    fi
  done
}

#
# cwuninstall
#
# uninstall some recipes
#
function cwuninstall() {
  cwsourcerecipes
  for recipe in "${@}" ; do
    if ! $(set | grep -q "^cwuninstall_${recipe}") ; then
      cwscriptecho "no uninstall found for ${recipe}"
      continue
    fi
    if $(cwlistinstalled | grep -q "^${recipe} :") ; then
      cwscriptecho "uninstalling ${recipe}"
      cwuninstall_${recipe}
    fi
  done
}

#
# cwenv
#
function cwenv() {
  cwsourcerecipes
  cwsourceprofile
  env
}

#
# cwset
#
function cwset() {
  cwsourcerecipes
  cwsourceprofile
  set
}

#
# cwlistfuncs
#
function cwlistfuncs() {
  cwset \
  | grep -F ' ()' \
  | cut -f1 -d' '
}

#
# cwrunfunc
#   receives:
#     at least one function name
#
# run a function that we know about
#
function cwrunfunc() {
  cwsourcerecipes
  cwsourceprofile
  for cwfunc in "${@}" ; do
    if ! $(set | grep -q "^${cwfunc} ") ; then
      cwscriptecho "function ${cwfunc} not known"
      continue
    fi
    ${cwfunc}
  done
}

#
# usage
#
function cwusage() {
  echo "usage: ${cwname} [command]"
  echo
  echo "commands:"
  for cwcmd in $(echo ${!cwcmds[@]} | tr ' ' '\n' | sort) ; do
    echo "  ${cwcmd} : ${cwcmds[${cwcmd}]}"
  done
  echo
}

#
# make sure we have a command
#
if [ ${#} -lt 1 ] ; then
  cwusage
  cwfailexit "exiting"
fi

#
# exit on unknown command
#
cmd="${1}"
if [[ ! ${cwcmdlist[@]} =~ ${cmd} ]] ; then
  cwfailexit "command ${cmd} not found"
fi
shift

#
# execute our given command
#
# XXX - commands will have additional arguments, i.e., package name for install, etc.
case "${cmd}" in
  bootstrap)
    cwbootstrap
    ;;
  update)
    cwupdate
    ;;
  env)
    # unnecessary, gratuitous use of cat
    test -e "${cwetc}/profile" && \
      cat "${cwetc}/profile" \
      | sed "s#^\(cwetcdir\)=.*#\1=${cwetc}#g" \
      | sed "s#^\(cwbindir\)=.*#\1=${cwbin}#g" \
      | sed "s#^\(cwtop\)=.*#\1=${cwtop}#g"
    ;;
  profile)
    cwprofileline
    ;;
  list-recipes)
    cwlistrecipes
    ;;
  list-installed)
    cwlistinstalled
    ;;
  list-available)
    cwlistavailable
    ;;
  install)
    cwinstall "${@}"
    ;;
  uninstall)
    cwuninstall "${@}"
    ;;
  set)
    cwset
    ;;
  list-funcs)
    cwlistfuncs
    ;;
  run-func)
    cwrunfunc "${@}"
    ;;
  show-env)
    cwenv
    ;;
  help)
    cwusage
    ;;
  *)
    cwfailexit "command ${cmd} not found"
    ;;
esac
